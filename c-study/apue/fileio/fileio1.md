## 文件I/O

UNIX 系统中大多数文件I/O只需用到5个函数: open. read. write. lseek以及close. 
    
**不带缓冲的I/0** (unbuffered I/O)是指每个read和write都调用内核中的一个系统调用.

对于内核而言,所有打开的文件都是通过**文件描述符**引用. 文件描述符是一个非负整数. 当打开一个现有文件或创建一个新文件时. 内核向进程返回一个文件描述符.当读.写一个文件时,使用open或create返回的文件描述符标识该文件,将其作为一个参数传送给read或write.

    按照惯例,UNIX系统shell把文件描述符0于进程的标准输入关联, 文件描述符1与标准输出关联, 文件描述符2与标准错误关联. 
    这是各种shell以及很多程序使用的惯例,与UNIX内核无关.尽管如此,如果不遵循这种惯例,很多UNIX系统程序就不能正常工作.

文件描述符的变化范围是0~~OPEN_MAX-1,早期的UNIX系统实现采用的上限是19(允许每个进程最多打开20个文件), 但现在你很多系统将其上限增加至63.

调用 **open** 或 **openat** 函数可以打开或创建一个文件

***
    #include <fcntl.h> 
     
    int open(const char *path, int oflag,... /* mode_t mode */);   
     
    int openat(int fd, const char *path, int oflag, ... /* mode_t mode */ );  
     
    两函数的返回值：若成功，返回文件描述符；若出错，返回−1 
***
path 参数是要打开或创建的文件的名称, oflag参数可用来说明该函数的多个选项. 用下列一个或多个常量进行 "或" 运算构成oflag参数.

|        参数        |           含义            |
|:------------------:|:-------------------------:|
|    O_RDONLY        |  只读打开
|    O_WRONLY        |  只写打开
|    O_RDWR          |  读,写打开
|    O_EXEC          |  只执行打开
|    O_SEARCH        |  只搜索打开(应用于目录)
|    O_APPEND        |  每次写时都追加到文件的尾端
|    O_CLOEXEC       |  把FD_CLOEXEC常量设置为文件描述符标志
|    O_CREAT         |  若此文件不存在则创建它,使用此选项时,open函数需要同时说明第三个参数mode(openat函数需要说明第四个参数 mode), 用 mode 指定改文件的访问权限位.
|    O_DIRECTORY     |  如果 path 引用的不是目录,则出错
|    O_EXCL          |  如果同时指定了 O_CREAT, 而且文件已经存在,则出错. 用此可以测试一个文件是都存在,如果不存在,则创建此文件,这使得测试和创建两者成为一个原子操作
|    O_NOCTTY        |  如果 path 引用的是中断设备,则不将改设备分配作为此进程的控制终端
|    O_NOFOLLOW      |  如果 path 引用的是一个符号链接,则出错.
|    O_NONBLOCK      |  如果 path 引用的是一个FIFO, 一个块特殊文件或一个字符特殊文件则此选项为文件的本次打开操作和后续的I/O操作设置非阻塞方式
|    O_SYNC          |  使每次write等待物理I/O操作完成.包括由改write操作引起的文件属性更新所需的I/O.
|    O_TRUNC         |  如果此文件存在, 而且为只写或读写成功打开,则将其长度截取为0
|    O_TTY_INIT      |  如果打开一个还未打开的终端设备,设置非标准 termios 参数值,使其符合 Single UNIX Specification.
|    O_DSYNC         |  使每次write要等待物理I/O操作完成,但是如果该写操作并不影响读取刚写入的数据, 则不需要等待文件属性被更新.
|    O_RSYNC         |  使每一个以文件描述符作为参数的进行的read操作等待,直至所有对文件同一部分挂起的写操作都完成.

说明
* 大多数实现将O_RDONLY定义为0,O_WRONLY定义为1,O_RDWR定义为2,以与早期的程序兼容
* O_SEARCH常量的目的在于在目录打开时验证它的搜索权限.对目录的文件描述符的后续操作就不需要再次检查对该目录的搜索权限. 目前主流的操作系统都没有支持O_SEARCH
* O_RDONLY,O_WRONLY,O_RDWR,O_EXEC,O_SEARCH这五个常量必须指定一个且只能指定一个, 其余常量则是可选的
* O_DSYNC和O_SYNC标志有微妙的区别.仅当文件属性需要更新以反映文件数据变化 (例如: 更新文件大小以后反映文件中包含了更多的数据)时,  O_DSYNC标志才印象文件属性.而设置O_SYNC标志后,数据和属性总是同步更新.当文件用O_DSYNC标志打开,在重写其现有的部分内容时,文件时间属性不会同步更新.一次相反,如果文件是用O_SYNC标志打开,那么对该文件的每一次write都将在write返回前更新文件时间,这与是否改写现有字节或追加写文件无关.


**由open 和 openat 函数返回的文件描述符一定是最小的未用描述符数值.**  这一点被某些应用程序用来在标准输入,标准输出或标准错误上打开新的文件. 例如.一个应用程序可以先关闭标准输出(通常文件描述符是1),然后打开另一个文件,执行打开操作前就能了解到该文件一定会在文件描述符1上打开. 使用dup2函数时可以了解到有更好的方法来保证在一个给定的文件描述符上打开一个文件

fd 参数把 open 和 openat 函数分开,总共有3中可能  <br>
 (1) path 参数指定的是绝对路径名, 在这种情况下, fd参数被忽略, openat函数相当于open函数. <br>
 (2) path 参数指定的是相对路径名,fd参数指出了相对路径名在文件系统中的开始地址. fd 参数是通过打开相对路径所在的目录来获取. <br>
 (3) path 参数制定了相对路径, fd 参数具有特殊值 AT_FDCWD.在这种情况下,路径名在当前工作目录中获取. openat 函数在操作上与 open 函数类似.
 
 openat 函数的出现希望解决两个问题. 第一, 让线程可以使用相对路径打开目录中的文件,而不再只能打开当前工作目录. 同一进程中的所有线程共享相同的当前工作目录,因此很难让同一进程的多个不同线程在同一时间工作在不同的目录中. 第二, 可以避免 time-of-check-to-time-of-use(TOCTTOU)错误.
 
 **TOCTTOU**错误的基本思想是: 如果有两个基于文件的函数调用,其中第二个调用依赖于第一个调用的结果,那么程序是脆弱的,因为两个调用并不是原子操作,在两个调用之间文件可能已经改变了,这样也就造成了一个调用的结果不在有效,使得程序最终的结果是错误的.文件系统命名空间中的TOCTTOU错误通常处理的就是那些颠覆文件系统权限的小把戏,这些小把戏通过骗取特权程序降低特权文件的权限控制或者让特权文件打开一个安全漏洞等方式进行.
 
 
 **函数 create**
 ***
     int Create(const char *path, mode_t mode)
     返回值: 若成功,返回只写打开的文件描述符; 如出错返回-1
 ***
 此函数等效于
 ***
     open(path, O_WRONLY|O_CREAT|O_TRUNC, mode)
 ***
   早期的UNIX系统版本中,open的第二个参数只能是0,1或2. 无法打开一个尚未存在的文件,因此需要另一个系统调药create以创建新文件,现在open函数提供了O_CREAT 和 O_TRUNC于是也就不需要但是得create函数了.
   
 create的一个不足之处是他以只写方式打开所创建的新文件,在提供open的新版本之前,如果要创建一个临时文件,想要先写文件然后又读该文件,则必须先调用create,close,然后在调用open, 现在则可以用下面的方式调用open实现.
 ***
     open(path, O_RDWR|O_CREAT|O_TRUNC, mode)
 ***
 
 **函数 close**
 调用close函数可以关闭一个打开文件
 ***
     int close(int fd)
 ***
 关闭一个文件时还会释放该进程加在该文件上的所有记录锁. <br>
 当一个进程终止时,内核自动关闭它打开的所有文件.很多程序利用了这一功能而不是显式的用close关闭打开文件.